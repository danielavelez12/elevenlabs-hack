import { TypedEventTarget } from 'typescript-event-target';

var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
class AudioInputDevicesStore extends TypedEventTarget {
  constructor() {
    super();
    __publicField$1(this, "_permissionState", "prompt");
    __publicField$1(this, "_devices", []);
    // updateDeviceList is used to handle device enumeration once permissions have been given
    __publicField$1(this, "updateDeviceList", async (promptIfFirefox) => {
      const isFirefox = navigator.userAgent.search("Firefox") > 0;
      if (promptIfFirefox && isFirefox) {
        await navigator.mediaDevices.enumerateDevices();
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
            video: false
          });
          for (const track of stream.getTracks()) {
            track.stop();
          }
        } catch (e) {
          throw new Error("Tried to create media stream but it didn't work");
        }
      }
      const devices = await navigator.mediaDevices.enumerateDevices();
      const filtered = devices.filter((device) => {
        return device.kind === "audioinput" && device.deviceId !== "";
      });
      this.devices = filtered;
    });
    if (typeof window === "undefined") return;
    this.updateDeviceList();
    navigator.mediaDevices.addEventListener("devicechange", () => {
      this.updateDeviceList();
    });
    navigator.permissions.query({ name: "microphone" }).then((permissionStatus) => {
      this.permissionState = permissionStatus.state;
      permissionStatus.addEventListener("change", () => {
        this.permissionState = permissionStatus.state;
      });
    }).catch((e) => {
      console.warn("browser does not support microphone permissions query");
    });
    this.addEventListener("changePermissions", () => {
      if (this.permissionState === "granted") {
        this.updateDeviceList(true);
      }
    });
  }
  get permissionState() {
    return this._permissionState;
  }
  set permissionState(value) {
    this._permissionState = value;
    this.dispatchTypedEvent(
      "changePermissions",
      new Event("changePermissions")
    );
  }
  get devices() {
    return this._devices;
  }
  set devices(devices) {
    if (devices !== this._devices) {
      this._devices = devices;
      this.dispatchTypedEvent("changeDevices", new Event("changeDevices"));
    }
  }
  async promptPermissions() {
    if (this.permissionState !== "prompt") return;
    this.permissionState = "prompting";
    try {
      const mediaStream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: false
      });
      if (mediaStream) {
        this.permissionState = "granted";
      }
    } catch (e) {
      this.permissionState = "denied";
    }
  }
}
let audioDevicesStore = null;
function getAudioDevicesStore() {
  audioDevicesStore ?? (audioDevicesStore = new AudioInputDevicesStore());
  return audioDevicesStore;
}

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
const RECORDING_STARTED = "recordingStarted";
const RECORDING_STOPPED = "recordingStopped";
const AUDIO = "audio";
const MUTE = "mute";
const UNMUTE = "unmute";
class InputAudioEvent extends Event {
  constructor(data) {
    super(AUDIO);
    this.data = data;
  }
}
class MuteEvent extends Event {
  constructor() {
    super(MUTE);
  }
}
class UnmuteEvent extends Event {
  constructor() {
    super(UNMUTE);
  }
}
class PCMRecorder extends TypedEventTarget {
  constructor(workletScriptURL) {
    super();
    this.workletScriptURL = workletScriptURL;
    __publicField(this, "mediaStream");
    __publicField(this, "audioContext");
    __publicField(this, "inputSourceNode");
    __publicField(this, "_analyser");
  }
  get analyser() {
    return this._analyser;
  }
  get isRecording() {
    return this.mediaStream?.active ?? false;
  }
  async startRecording(options) {
    this.audioContext = options.audioContext;
    try {
      await this.audioContext.audioWorklet.addModule(this.workletScriptURL);
    } catch (err) {
      throw new AudioModuleRegistrationError(this.workletScriptURL, err);
    }
    const constraints = {
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: true,
      ...options.recordingOptions ?? {}
    };
    this.mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        deviceId: options.deviceId,
        ...constraints
      }
    });
    this.inputSourceNode = this.audioContext.createMediaStreamSource(
      this.mediaStream
    );
    const processor = new AudioWorkletNode(
      this.audioContext,
      "pcm-audio-processor"
    );
    processor.port.onmessage = (event) => {
      const inputBuffer = event.data;
      this.dispatchTypedEvent(AUDIO, new InputAudioEvent(inputBuffer));
    };
    this.inputSourceNode.connect(processor);
    processor.connect(this.audioContext.destination);
    this._analyser = this.audioContext.createAnalyser();
    this.inputSourceNode.connect(this._analyser);
    this.dispatchTypedEvent(RECORDING_STARTED, new Event(RECORDING_STARTED));
  }
  mute() {
    if (!this.mediaStream) return;
    for (const track of this.mediaStream.getTracks()) {
      console.log(track);
      track.enabled = false;
    }
    this.dispatchTypedEvent(MUTE, new MuteEvent());
  }
  unmute() {
    if (!this.mediaStream) return;
    for (const track of this.mediaStream.getTracks()) {
      track.enabled = true;
    }
    this.dispatchTypedEvent(UNMUTE, new UnmuteEvent());
  }
  get isMuted() {
    return this.mediaStream?.getAudioTracks().some((track) => !track.enabled) ?? false;
  }
  stopRecording() {
    if (this.mediaStream) {
      for (const track of this.mediaStream.getTracks()) {
        track.stop();
      }
      this.inputSourceNode?.disconnect();
      this.mediaStream = void 0;
      this.inputSourceNode = void 0;
      this._analyser = void 0;
      this.audioContext = void 0;
      this.dispatchTypedEvent(RECORDING_STOPPED, new Event(RECORDING_STOPPED));
    }
  }
}
class AudioModuleRegistrationError extends Error {
  constructor(moduleUrl, error) {
    super(`Failed to register module from ${moduleUrl}`, { cause: error });
    this.name = "AudioModuleRegistrationError";
  }
}

export { AudioInputDevicesStore, AudioModuleRegistrationError, InputAudioEvent, MuteEvent, PCMRecorder, UnmuteEvent, getAudioDevicesStore };
